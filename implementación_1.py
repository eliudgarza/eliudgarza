# -*- coding: utf-8 -*-
"""ImplementaciÃ³n_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/eliudgarza/eliudgarza/blob/main/Implementaci%C3%B3n_1.ipynb

Eliud Garza A00827575
"""

from google.colab import drive
drive.mount("/content/gdrive")

!pwd

# Commented out IPython magic to ensure Python compatibility.
# %cd "/content/gdrive/MyDrive/7mo Semestre/Modulo 2/Titanic"

!ls

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

x_tn = pd.read_csv("X_train.txt")
y_tn = pd.read_csv("Y_train.txt")

x_tt = pd.read_csv("X_test.txt")
y_tt = pd.read_csv("Y_test.txt")

x_tn.head()

y_tn.head()

x_tt.head()

y_tt.head()

x_tn = x_tn.drop("Id", axis = 1)
y_tn = y_tn.drop("Id", axis = 1)
x_tt = x_tt.drop("Id", axis = 1)
y_tt = y_tt.drop("Id", axis = 1)

x_tn = x_tn.values
y_tn = y_tn.values
x_tt = x_tt.values
y_tt = y_tt.values

x_tn = x_tn.T
y_tn = y_tn.reshape(1,x_tn.shape[1])
x_tt = x_tt.T
y_tt = y_tt.reshape(1,x_tt.shape[1])

def sigmoid(x):
  return 1/(1 + np.exp(-x))

def model(X, Y, learning_rate, iterations):
    x0 = x_tn.shape[1]
    x1 = x_tn.shape[0]
    P = np.zeros((x1,1))
    O = 0
    cost_list = []
    for i in range(iterations):
        Q = np.dot(P.T, X) + O
        R = sigmoid(Q)
        cost = -(1/x0)*np.sum( Y*np.log(R) + (1-Y)*np.log(1-R)) # cost function
        # Gradient Descent
        dP = (1/x0)*np.dot(R-Y, X.T)
        dO = (1/x0)*np.sum(R - Y)
        P = P - learning_rate*dP.T
        O = O - learning_rate*dO
        # Keeping track of our cost function value
        cost_list.append(cost)
        if(i%(iterations/10) == 0):
            print("iterations: ", i, "cost: ", cost)
    return P, O, cost_list

iterations = 100000
learning_rate = 0.0015
P, O, cost_list = model(x_tn, y_tn, learning_rate = learning_rate, iterations = iterations)

plt.plot(np.arange(iterations), cost_list)
plt.show()

def accuracy(X, Y, P, O):
    Q = np.dot(P.T, X) + O
    R = sigmoid(Q)
    R = R > 0.5
    R = np.array(R, dtype = 'int64')
    acc = (1 - np.sum(np.absolute(R - Y))/Y.shape[1])*100
    print("Accuracy of the model is : ", round(acc, 2), "%")

accuracy(x_tt, y_tt, P, O)